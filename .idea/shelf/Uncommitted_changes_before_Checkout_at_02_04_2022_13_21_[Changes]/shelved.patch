Index: src/main/kotlin/Main.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n// stepik 6.4\r\n/*\r\n* Первая строка содержит число n до 10^5, вторая — массив A[1..n], содержащий натуральные числа, не превосходящие 10^9.\r\n* Необходимо посчитать число пар индексов 1≤i<j≤n, для которых A[i]>A[j].\r\n* (Такая пара элементов называется инверсией массива. Количество инверсий в массиве является в некотором смысле\r\n* его мерой неупорядоченности: например, в упорядоченном по неубыванию массиве инверсий нет вообще,\r\n* а в массиве, упорядоченном по убыванию, инверсию образуют каждые два элемента.)\r\n\r\n5\r\n2 3 9 2 9\r\n\r\n2\r\n\r\n\r\n* */\r\n\r\nfun main() {\r\n\tvar n: Int = readLine().toString().toInt()\r\n        val str = readLine().toString().split(\" \")\r\n        val kk = mutableListOf<Long>()\r\n        var nn = mutableListOf<Long>()\r\n        var x: Int\t// начало текущей пары массивов\r\n        var i = 0\t// текущий индекс 1го массива\r\n        var j = 0\t// текущий индекс 2го массива\r\n        var d = 1\t// шаг, длина сравниваемых массивов\r\n        n = 0\t\t// счетчик инверсий\r\n\r\n        for (i in 0 .. str.lastIndex) {\r\n            // Преобразуем стринг в массив Лонг\r\n            nn.add(str[i].toLong())\r\n        }\r\n    if (nn.size < 2) {\r\n        println(\"0\")\r\n        return\r\n    }\r\n    while (d < nn.size) {\r\n        x = 0\r\n\r\n        while (x + d <= nn.lastIndex) {\r\n            i = x\r\n            j = i + d\r\n            while (i < x + d || j < x + d + 1) {\r\n                if (i < x + d && j < x + (2 * d) && j <= nn.lastIndex) {\r\n                    if (nn[i] <= nn[j]) {\r\n                        kk.add(nn[i])\r\n                        i += 1\r\n                    } else {\r\n//                        n += x + d - i\r\n                        kk.add(nn[j])\r\n                        n += j - kk.lastIndex\r\n                        println(\"n=$n, j=$j, ind=${kk.lastIndex}, kk=$kk\")\r\n                        j += 1\r\n                    }\r\n                } else {\r\n                    if (i >= x + d) {\r\n                        kk.add(nn[j])\r\n                        j += 1\r\n                    } else {\r\n                        kk.add(nn[i])\r\n                        i += 1\r\n                    }\r\n                }\r\n            }\r\n            x += d * 2\r\n        }\r\n        println(\"nn=$nn kk=$kk\")\r\n        for (r in 0 .. kk.lastIndex) {\r\n            nn[r] = kk[r]\r\n        }\r\n        kk.clear()\r\n        d *= 2\r\n    }\r\n    println(n)\r\n}\r\n/*\r\n1\r\n1 2 3\r\n1\r\n3 2 1\r\n5\r\n2 3 9 2 9\r\n2\r\n6\r\n10 8 6 2 4 5\r\n12\r\n11\r\n1 2 3 4 5 6 7 8 3 4 3\r\n15\r\n*/\r\n\r\n\r\n\r\n// stepik 6.1\r\n/*fun main() {\r\n    var str1 = readLine().toString()\r\n    var str2 = readLine().toString()\r\n\r\n    val nn = str1.split(\" \")\r\n    val kk = str2.split(\" \")\r\n    val result = mutableListOf<Int>()\r\n\r\n    var x: Int\r\n    var l: Int\r\n    var r: Int\r\n\r\n    for (i in 1..kk.size-1) {\r\n        r = nn.size-1\r\n        l = 1\r\n        x = -1\r\n        while (r >= l) {\r\n            if (nn[(r+l)/2] == kk[i]) {\r\n                x = (r + l) / 2\r\n                break\r\n            } else {\r\n                if ((nn[(r + l)/2]).toLong() < kk[i].toLong()) {\r\n                    l = ((r + l) / 2) + 1\r\n                } else {\r\n                    r = ((r + l) / 2) - 1\r\n                }\r\n            }\r\n        }\r\n        result.add(x)\r\n    }\r\n    for (i in result) print(\"$i \")\r\n}\r\n*/\r\n/*\r\n5 1 5 8 12 13\r\n5 8 1 23 1 11\r\n* */\r\n\r\n// stepik 4.3\r\n// Очередь с приоритетами\r\n\r\n//fun main() {\r\n//    val n = readLine()!!.toInt()     // количество операций\r\n//    var str: String     // строка ввода (Insert x или  ExtractMax)\r\n//    var listZn = mutableListOf<Long>()  // очередь\r\n//    var index: Int\r\n//    var indexMin:Int\r\n//    var y: Long\r\n//\r\n//    for (i in 1..n) {\r\n//        str = readLine().toString()\r\n//\r\n//        if (str == \"ExtractMax\") {\r\n//            println(listZn[0])\r\n//            listZn[0] = listZn[listZn.lastIndex]\r\n//            listZn.removeAt(listZn.lastIndex)\r\n//\r\n//            if (listZn.size > 1) {\r\n//                    index = 0\r\n//                    while ( (listZn.lastIndex > (index * 2)) && (listZn[index] < listZn[(index * 2) + 1])\r\n//                        || (listZn.lastIndex > (index * 2) + 1) && (listZn[index] < listZn[(index * 2) + 2]) )\r\n//                        {\r\n//                            y = listZn[index]\r\n//\r\n//                            if (listZn.lastIndex > (index * 2) + 1) {\r\n//                                if (listZn[(index * 2) + 1] > listZn[(index * 2) + 2]) {\r\n//                                    indexMin = (index * 2) + 1\r\n//                                } else indexMin = (index * 2) + 2\r\n//                            } else {\r\n//                                indexMin = (index * 2) + 1\r\n//                            }\r\n//\r\n//                            listZn[index] = listZn[indexMin]\r\n//                            listZn[indexMin] = y\r\n//                            index = indexMin\r\n//                    }\r\n//                }\r\n//\r\n//        } else {\r\n//\r\n//            listZn.add(str.substringAfter(\" \").toLong())\r\n//\r\n//            if (listZn.size > 1) {\r\n//                index = listZn.lastIndex\r\n//                while (listZn[index] > listZn[(index - 1) / 2]) {\r\n//                    y = listZn[index]\r\n//                    listZn[index] = listZn[(index - 1) / 2]\r\n//                    listZn[(index - 1) / 2] = y\r\n//                    index = (index - 1) / 2\r\n//                }\r\n//            }\r\n//        }\r\n//    }\r\n//}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\nstepik 4.2\r\n\r\n */\r\n/*\r\nfun main() {\r\n    var s = readLine()!!.toString()\r\n    val k = s.substringBefore(' ').toInt()\r\n    val l = s.substringAfter(' ').toInt()\r\n    var let = mutableListOf<String>()\r\n    var kod = mutableListOf<String>()\r\n\r\n    for (i in 1 .. k) {\r\n        s = readLine()!!.toString()\r\n        let.add(s.substringBefore(':').toString())\r\n        kod.add(s.substringAfter(' ').toString())\r\n    }\r\n    s = \"\"\r\n    var strKod = readLine()!!.toString()\r\n    var str = \"\"\r\n\r\n    while (strKod.length > 0) {\r\n        for (i in 1..strKod.length) {\r\n            str = \"$str${strKod[i-1]}\"\r\n            if (kod.contains(str)) {\r\n                strKod = strKod.drop(str.length)\r\n                s = \"$s${let[kod.indexOf(str)]}\"\r\n                str = \"\"\r\n            }\r\n        }\r\n    }\r\n    print(s)\r\n}\r\n*/\r\n\r\n\r\n\r\n\r\n/* 4.2\r\n* По данной непустой строке s длины не более 10^4, состоящей из строчных букв латинского алфавита,\r\n* постройте оптимальный беспрефиксный код. В первой строке выведите количество различных букв k,\r\n* встречающихся в строке, и размер получившейся закодированной строки.\r\n* В следующих kk строках запишите коды букв в формате \"letter: code\". В последней строке выведите закодированную строку.\r\n* */\r\n/*\r\nfun main() {\r\n    var s = readLine()!!.toString()     // Входная строка\r\n    val k = mutableListOf<String>()     // Список уникальных символов в s\r\n    val n = mutableListOf<Int>()        //Количество повторений символа из k в s\r\n    val kod = mutableListOf<String>()   // коды для букв, упорядоченных по частоте использования\r\n    var sym = mutableListOf<String>()   // массив букв, упорядоченных по частоте использования\r\n    val tempSym = mutableListOf<String>()\r\n    val tempFrq = mutableListOf<Int>()\r\n    val tempKod = mutableListOf<String>()\r\n    var str = \"\"                        // вспомогательная строка\r\n\r\n    // Запоняем списки уникальных букв и их частоты\r\n    for (i in s) {\r\n        if (k.contains(\"$i\")) {\r\n            n[k.indexOf(\"$i\")] += 1\r\n        } else {\r\n            k.add(\"$i\")\r\n            n.add(1)\r\n        }\r\n    }\r\n    for (i in k) {\r\n        sym.add(i)\r\n        kod.add(\"\")\r\n    }\r\n\r\n    while (k.size > 1) {\r\n        for (i in 1..2) {\r\n            tempSym.add(k[n.indexOf(n.minOrNull())])\r\n            tempFrq.add(n[n.indexOf(n.minOrNull())])\r\n            k.removeAt(n.indexOf(n.minOrNull()))\r\n            n.removeAt(n.indexOf(n.minOrNull()))\r\n            tempKod.add(\"${2 - i}\")\r\n        }\r\n        k.add(\"${tempSym[tempSym.lastIndex]}${tempSym[tempSym.lastIndex - 1]}\")\r\n        n.add(tempFrq[tempFrq.lastIndex] + tempFrq[tempFrq.lastIndex - 1])\r\n    }\r\n\r\n    if (sym.size > 1) {\r\n        for (i in 0..sym.size - 1) {\r\n            for (j in 0..tempSym.size - 1) {\r\n                if (tempSym[j].contains(sym[i])) {\r\n                    kod[i] = \"${tempKod[j]}${kod[i]}\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (sym.size == 1) {\r\n        kod[0] = \"0\"\r\n    }\r\n\r\n    for (i in s.toString()) {\r\n        str = \"$str${kod[sym.indexOf(i.toString())]}\"\r\n    }\r\n\r\n    print(\"${sym.size} \")\r\n    println(str.length)\r\n    for (j in sym) {\r\n        println(\"$j: ${kod[sym.indexOf(\"$j\")]}\")\r\n    }\r\n    print(str)\r\n}\r\n*/\r\n\r\n//if (sym.size % (count * 2) == 0) {\r\n//        while (2.0.pow(count.toDouble()) <= sym.size) {\r\n//            for (i in 1..count) {\r\n//                if (i < sym.size) {\r\n//                    kod[i-1] = \"0${kod[i-1]}\"\r\n//                    kod[i] = \"1${kod[i]}\"\r\n//                }\r\n//            }\r\n//            count *= 2\r\n//        }\r\n//    } else {\r\n//        while (2.0.pow(count.toDouble()) <= sym.size) {\r\n////            while (count+1 <= sym.size) {\r\n//                for (i in count + 1..count * 2) {\r\n//                if (i < sym.size) {\r\n//                    kod[i-1] = \"0${kod[i-1]}\"\r\n//                    kod[i] = \"1${kod[i]}\"\r\n//                }\r\n//            }\r\n//            count *= 2\r\n//        }\r\n//    }\r\n\r\n// str = \"0\"\r\n//        if (sym.size != 0) {\r\n//            for (i in 1..sym.size) {\r\n//                str = \"1$str\"\r\n//            }\r\n//            if (sym.size > 1 && k.size == 1) {\r\n//                str = str.dropLast(2)\r\n//                str = \"${str}1\"\r\n//            }\r\n//        }\r\n\r\n\r\n\r\n\r\n/*\r\n* По данному числу n (от 1 до 10^9) найдите максимальное число k,\r\n* для которого n можно представить как сумму k различных натуральных слагаемых.\r\n* Выведите в первой строке число k, во второй — k слагаемых.\r\n* */\r\n/*\r\nfun main() {\r\n    val n: Int = readLine()!!.toInt() // Исходное число\r\n    var k = mutableListOf<Int>()  // Слагаемые\r\n    var x = 10\r\n    var y = 5\r\n\r\n    if (n<10) {\r\n        k = when (n) {\r\n            1 -> mutableListOf(1)\r\n            2 -> mutableListOf(2)\r\n            3 -> mutableListOf(1, 2)\r\n            4 -> mutableListOf(1, 3)\r\n            5 -> mutableListOf(2, 3)\r\n            6 -> mutableListOf(1, 2, 3)\r\n            7 -> mutableListOf(1, 2, 4)\r\n            8 -> mutableListOf(1, 2, 5)\r\n            9 -> mutableListOf(2, 3, 4)\r\n            else -> {mutableListOf(1, 2, 3, 4)}\r\n        }\r\n    }\r\n    println(k)\r\n    while (x+y < n) {\r\n        x += y\r\n        y += 1\r\n        k.add(y)\r\n    }\r\n    println(\"x = $x, y = $y\")\r\n    println(\"size = ${k.size}\")\r\n    println(k)\r\n}\r\n*/\r\n\r\n\r\n// непрерывный рюкзак\r\n/*fun main() {\r\n    var str: String? = \"\"        // Строки из консоли\r\n    var n: Int          // Количество данных предметов\r\n    var w: Double         // вместимость рюкзака\r\n    var cost: Double = 0.0     // стоимость рюкзака\r\n    var x: Int\r\n    var y: String\r\n\r\n    val cc = mutableListOf<Long>()   // стоимости предметов\r\n    val ww = mutableListOf<Double>()   // объемы предметов\r\n    val cw = mutableListOf<Double>() // удельная стоимость предмета\r\n\r\n//    val bpW = mutableListOf<Float>()    // вес предметов в рюкзаке\r\n//    val bpC = mutableListOf<Float>()    // стоимость предметов в рюкзаке\r\n\r\n    str = readLine()!!\r\n    n = str.substringBefore(' ').toInt()\r\n    w = str.substringAfter(' ').toDouble()\r\n\r\n    for (i in 1..n) {\r\n        str = readLine()\r\n        y = str?.substringBefore(' ').toString()\r\n        cc.add(y.toLong())\r\n        y = str?.substringAfter(' ').toString()\r\n        ww.add(y.toDouble())\r\n        cw.add(cc[i-1].toDouble()/ww[i-1])\r\n    }\r\n    while (w > 0.000 && cw.size > 0) {\r\n        x = cw.indexOf(cw.maxOrNull())\r\n        if (ww[x] <= w) {\r\n            cost += cc[x].toDouble()\r\n            w -= ww[x]\r\n            ww.removeAt(x)\r\n            cc.removeAt(x)\r\n            cw.removeAt(x)\r\n        } else {\r\n            cost += cc[x].toDouble() * (w/ww[x])\r\n            w = 0.000\r\n        }\r\n    }\r\n    println(cost)\r\n}*/\r\n\r\n\r\n\r\n\r\n/*По данным nn отрезкам необходимо найти множество точек минимального размера, для которого каждый из отрезков содержит хотя бы одну из точек*/\r\n/*fun main() {\r\n    var n: Int = readLine()!!.toInt()\r\n    var z: String = \"\"\r\n    var l = mutableListOf<Long>()\r\n    var r = mutableListOf<Long>()\r\n    var sm = mutableListOf<Int>()\r\n    var dots = mutableListOf<Long>()\r\n    var x: Int\r\n    var y: Long\r\n\r\n    for (i in 1..n) {\r\n        z = readLine()!!\r\n        l.add(z.substringBefore(' ').toLong())\r\n        r.add(z.substringAfter(' ').toLong())\r\n    }\r\n\r\n    while (l.size > 0) {\r\n        sm.clear()\r\n        x = r.indexOf(r.minOrNull()!!)\r\n        y = r[x]\r\n        dots.add(y)\r\n\r\n        for (i in 0 .. l.size-1) {\r\n            if (l[i] < y || l[i] == y) {\r\n                sm.add(i)\r\n            }\r\n        }\r\n        for (i in sm.size-1 downTo 0) {\r\n            x = sm[i]\r\n            l.removeAt(x)\r\n            r.removeAt(x)\r\n        }\r\n    }\r\n\r\n    println(dots.size)\r\n    for (i in 0 .. dots.size-1) {\r\n        print(dots[i])\r\n        if (i != dots.lastIndex) {\r\n            print(\" \")}\r\n    }\r\n}\r\n*/\r\n\r\n\r\n\r\n/* Найти остаток от деления Fn на m */\r\n//fun  main() {\r\n//    val str = readLine().toString()\r\n//    var n = str.substringBefore(' ').toLong() // n-ное число F\r\n//    var m = str.substringAfter(' ').toLong()  // делитель\r\n//    var x:Long = 0      //Fn-2\r\n//    var y:Long = 1    //Fn-1\r\n//    var z:Long = 0    //Fn\r\n//    if(n<=1) {\r\n//        z = n\r\n//    } else {\r\n//        for (i in 2..n) {\r\n//            z=(x+y)\r\n//            print(z%m)\r\n//            x = y\r\n//            y = z\r\n//            println(\"x=$x, y=$y, z=$z\")\r\n//        }\r\n//    }\r\n//    println (z%m)\r\n//}\r\n\r\n/* Найти наибольший общий делитель */\r\n//fun  main() {\r\n//    val str = readLine().toString()\r\n//    var a = str.substringBefore(' ').toLong()\r\n//    var b = str.substringAfter(' ').toLong()\r\n//    while (a>0 && b>0) {\r\n//        if (a>=b) {\r\n//            a=a%b\r\n//        } else {\r\n//            b=b%a\r\n//        }\r\n//    }\r\n//    println(max(a,b))\r\n//}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/kotlin/Main.kt b/src/main/kotlin/Main.kt
--- a/src/main/kotlin/Main.kt	
+++ b/src/main/kotlin/Main.kt	
@@ -1,3 +1,8 @@
+fun main() {
+    
+}
+
+
 
 // stepik 6.4
 /*
@@ -14,9 +19,9 @@
 
 
 * */
-
+/*
 fun main() {
-	var n: Int = readLine().toString().toInt()
+	var n: Long = readLine().toString().toLong()
         val str = readLine().toString().split(" ")
         val kk = mutableListOf<Long>()
         var nn = mutableListOf<Long>()
@@ -40,16 +45,15 @@
         while (x + d <= nn.lastIndex) {
             i = x
             j = i + d
-            while (i < x + d || j < x + d + 1) {
+
+            while (i < x + d || (j < x + (d * 2) && j < nn.size)) {
                 if (i < x + d && j < x + (2 * d) && j <= nn.lastIndex) {
                     if (nn[i] <= nn[j]) {
                         kk.add(nn[i])
                         i += 1
                     } else {
-//                        n += x + d - i
                         kk.add(nn[j])
                         n += j - kk.lastIndex
-                        println("n=$n, j=$j, ind=${kk.lastIndex}, kk=$kk")
                         j += 1
                     }
                 } else {
@@ -64,7 +68,6 @@
             }
             x += d * 2
         }
-        println("nn=$nn kk=$kk")
         for (r in 0 .. kk.lastIndex) {
             nn[r] = kk[r]
         }
@@ -73,6 +76,7 @@
     }
     println(n)
 }
+*/
 /*
 1
 1 2 3
